"use strict";

function info(my) {
    var promise = Array.call();
    if (my.pid && promise.push([ "pid", function() {
        return process.pid;
    } ]), my.bytesReq && promise.push([ "bytesReq", function(req) {
        return req.socket.bytesRead;
    } ]), my.bytesRes && promise.push([ "bytesRes", function(req) {
        return req.socket._bytesDispatched;
    } ]), my.referrer && promise.push([ "referrer", function(req) {
        return req.headers.referer || req.headers.referrer;
    } ]), my.auth) {
        var mod0 = require("basic-authentication")({
            legacy: !0
        });
        promise.push([ "auth", function(req) {
            return mod0(req).user;
        } ]);
    }
    if (my.transfer) {
        var mod1 = require("transfer-rate")();
        promise.push([ "transfer", function(req) {
            return mod1(req, req.start);
        } ]);
    }
    my.agent && promise.push([ "agent", function(req) {
        return req.headers["user-agent"];
    } ]), my.lang && promise.push([ "lang", function(req) {
        return req.headers["accept-language"];
    } ]), my.cookie && promise.push([ "cookie", function(req) {
        return req.cookies;
    } ]), my.cookie && promise.push([ "headers", function(req) {
        return req.headers;
    } ]), my.version && promise.push([ "version", function(req) {
        return req.httpVersionMajor + "." + req.httpVersionMinor;
    } ]), my.callback && promise.push([ "callback", function(req) {
        return my.callback(req);
    } ]);
    var l = promise.length;
    return 0 === l ? function(req, statusCode, end) {
        var diff = 1e3 * end[0] + 1e-6 * end[1];
        return {
            ip: req.remoteAddr || req.ip,
            method: req.method,
            status: statusCode,
            url: req.url,
            response: diff.toFixed(2)
        };
    } : function(req, statusCode, end) {
        for (var diff = 1e3 * end[0] + 1e-6 * end[1], out = {
            ip: req.remoteAddr || req.ip,
            method: req.method,
            status: statusCode,
            url: req.url,
            response: diff.toFixed(2)
        }, i = 0; l > i; i++) {
            var p = promise[i];
            out[p[0]] = p[1](req);
        }
        return out;
    };
}

function wrapper(log, my, io) {
    function finale(req, statusCode, start) {
        var end = process.hrtime(start);
        return req.start = start, log(my.logger, io(req, statusCode, end));
    }
    var finished = require("on-finished");
    return my.deprecated ? (console.error("warning! `logger-request` option is deprecated"), 
    function(req, res, next) {
        var start = process.hrtime();
        if (req.remoteAddr = req.ip, res._headerSent) finale(req, res.statusCode, start); else {
            var buffer = res.end;
            res.end = function(chunk, encoding) {
                res.end = buffer;
                var b = res.end(chunk, encoding);
                return finale(req, res.statusCode, start), b;
            };
        }
        next && next();
    }) : my.functions ? function(req, res) {
        req.remoteAddr = req.ip;
        var start = process.hrtime();
        return finale(req, res.statusCode, start);
    } : function(req, res, next) {
        var start;
        return req.remoteAddr = req.ip, finished(res, function() {
            return finale(req, res.statusCode, start);
        }), start = process.hrtime(), next();
    };
}

function logger(opt) {
    var options = opt || Object.create(null), my = {
        filename: require("path").resolve(String(options.filename || "route.log"))
    };
    Boolean(options.deprecated) ? my.deprecated = !0 : Boolean(options.functions) && (my.functions = !0), 
    options.winston = options.winston || Object.create(null);
    var winston = {
        filename: my.filename,
        logger: String(options.winston.logger || "logger-request"),
        level: String(options.winston.level || "info"),
        silent: Boolean(options.winston.silent),
        colorize: Boolean(options.winston.colorize),
        timestamp: options.winston.timestamp || !0,
        maxsize: Number(options.winston.maxsize) || 8388608,
        maxFiles: Number(options.winston.maxFiles) || null,
        json: options.winston.json === !1 ? !1 : !0,
        raw: options.winston.raw === !1 ? !1 : !0
    };
    my.logger = winston.logger;
    var log = require("winston").loggers.add(winston.logger, {
        console: {
            level: winston.level,
            silent: !Boolean(options.console),
            colorize: winston.colorize,
            timestamp: winston.timestamp,
            json: winston.json,
            raw: winston.raw,
            showLevel: !1
        },
        file: {
            level: winston.level,
            silent: winston.silent,
            colorize: winston.colorize,
            timestamp: winston.timestamp,
            filename: winston.filename,
            maxsize: winston.maxsize,
            maxFiles: winston.maxFiles,
            json: winston.json,
            showLevel: !1
        }
    })[winston.level];
    if (Boolean(options.standalone)) return log;
    options = options.custom || Object.create(null);
    var io = info({
        pid: Boolean(options.pid),
        bytesReq: Boolean(options.bytesReq),
        bytesRes: Boolean(options.bytesRes),
        referrer: Boolean(options.referrer),
        auth: Boolean(options.auth),
        transfer: Boolean(options.transfer),
        agent: Boolean(options.agent),
        lang: Boolean(options.lang),
        cookie: Boolean(options.cookie),
        headers: Boolean(options.headers),
        version: Boolean(options.version),
        callback: Boolean(options.callback) ? options.callback : !1
    });
    return wrapper(log, my, io);
}

module.exports = logger;
